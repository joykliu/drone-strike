{"version":3,"sources":["main.js"],"names":["url","droneApp","mapboxgl","getDrones","$","ajax","when","then","data","strike","map","result","filteringResult","Array","date","split","splice","m_names","getMonth","dateObj","year","on","param","input","value","getCheckedInputValue","toArray","checkedYears","checkedCountries","checkedValues","defaultValues","category","baseData","length","criteria","filter","singleStrike","filteredRaw","filteredResult","n","filteredStrikes","defaultYears","initMap","Map","displayStrikes","displayMarkers","undefined","forEach","lon","console","lat","log","deaths","time","town","link","summary","location","getPopupInfo","bij_summary_short","displayDate","numberReconstruct","number","join","Popup","offset","setHTML","el","document","createElement","markers","markerArr","push","setLngLat","setPopup","popup","addTo","fitMap","geojson","type","features","geometry","coordinates","bounds","reduce","coord","fitBounds","padding","init"],"mappings":"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","file":"main.min.js","sourcesContent":["// define callback url, app shell and mapbox key\nconst url = 'http://api.dronestre.am/data';\nconst droneApp = {};\nmapboxgl.accessToken = 'pk.eyJ1Ijoiam95OTAxN21hcGJveCIsImEiOiJjaW94M2RneXQwMDJ1d2ZtNXp4a29pbTV4In0.TebEkoRfRP8E0hw_Nd3PFA';\n\n// calling for drone results\n\ndroneApp.getDrones = $.ajax ({\n    url: url,\n    method: 'GET',\n    dataType: 'jsonp'\n});\n\n$.when(droneApp.getDrones).then(data => {\n    // show date as year form\n    droneApp.filteringResult = () => {\n        data.strike.map(result => {\n            const m_names = new Array(\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\");\n            result.date = result.date.split('-').splice(0,2);\n            result.year = result.date[0];\n            let dateObj = new Date(result.date);\n            const month = m_names[dateObj.getMonth()];\n            result.displayDate = `${month}, ${result.year}`;\n        })\n\n        $(`input[type=checkbox]`).on('change', ()=> {\n            // collect chekced values into an array\n            let getCheckedInputValue = (param) => {\n                return $(`input[name=${param}]:checked`).map((input, value) => {\n                    return $(value).val()\n                }).toArray();\n            }\n            // define checked and default values for filter use\n            const checkedYears = getCheckedInputValue('year');\n            const checkedCountries = getCheckedInputValue('country');;\n            const defaultCountries = ['Yemen', 'Somalia', 'Pakistan'];\n            const defaultYears = ['2002', '2004', '2005', '2006', '2007', '2008', '2009', '2010', '2011', '2012', '2013', '2014', '2015', '2016'];\n\n            // filter resutls\n            const filteringResult = (checkedValues, defaultValues, category, baseData) => {\n                if(checkedValues.length !== 0) {\n                    // when the user makes a selection filter data against checked boxes\n                    var filteredRaw = checkedValues.map((criteria) => {\n                        return baseData.filter((singleStrike) => {\n                            if (category === 'year') {\n                                return singleStrike.year === criteria\n                            } else if (category === 'country') {\n                                return singleStrike.country === criteria\n                            }\n                        })\n                    })\n                } else {\n                    // when no selection is made, show all possible results\n                    var filteredRaw = defaultValues.map((criteria) => {\n                        return baseData.filter((singleStrike) => {\n                            if (category === 'year') {\n                                return singleStrike.year === criteria\n                            } else if (category === 'country') {\n                                return singleStrike.country === criteria;\n                            }\n                        })\n                    })\n                }\n                // turn filtered result, a multilevel array, into a flattened array\n                var filteredResult = $.map(filteredRaw, function(n) {\n                    return n\n                })\n                data.filteredStrikes = filteredResult;\n                // return data;\n            }\n            // first call for data to be filtered with an original dataset\n            filteringResult(checkedYears, defaultYears, 'year', data.strike);\n            // then call for data to be filtered wiht an filtered dataset\n            filteringResult(checkedCountries, defaultCountries, 'country',data.filteredStrikes);\n        })\n    }\n\n    droneApp.initMap = () => {\n        droneApp.map = new mapboxgl.Map({\n            container: 'map',\n            style: 'mapbox://styles/mapbox/streets-v9'\n        })\n    }\n\n    droneApp.displayStrikes = () => {\n        // display map\n        droneApp.markerArr = [];\n        // create empty array to store markers\n        // display markers\n        const displayMarkers = () => {\n            if (data.filteredStrikes !== undefined) {\n                data.filteredStrikes.forEach((singleStrike) => {\n                    // define marker latitute and longtitute\n                    let lat = singleStrike.lat\n                    ,     lon = singleStrike.lon;\n                    console.log(singleStrike);\n                    // define information contained in popup\n                    let town, summary, link, deaths, time;\n                    //NOTEðŸ‘‡: DO NOT DO THIS FIND A WAY TO WRAP THIS BETTER\n                    const getPopupInfo = () => {\n                        if (singleStrike.town.length) {\n                            town = singleStrike.town;\n                        } else if (singleStrike.location.length){\n                            town = singleStrike.location\n                        } else {\n                            town = 'Unknown'\n                        }\n\n                        if (singleStrike.narrative.length) {\n                            summary = singleStrike.narrative\n                        } else if (singleStrike.bij_summary_short.length){\n                            summary = singleStrike.bij_summary_short\n                        } else {\n                            summary = 'Awaiting detailed information on this strike...'\n                        }\n\n                        if (singleStrike.bij_link.length) {\n                            link = singleStrike.bij_summary_short.length\n                        }\n\n                        if (singleStrike.displayDate.length) {\n                            time = singleStrike.displayDate\n                        }\n\n                        const numberReconstruct = () => {\n                            let number = singleStrike.deaths;\n                            if(number.length > 2) {\n                                deaths = number.split('-').join(' to ')\n                            } else {\n                                deaths = number;\n                            }\n                        }\n                        numberReconstruct();\n                    }\n                    getPopupInfo();\n                    const popup = new mapboxgl.Popup({offset: [0,0]}).setHTML(`\n                        <div class=\"marker-content\">\n                            <p>${time}</p>\n                            <h3>${town}</h3>\n                            <h4>Deaths: ${deaths}</h4>\n                            <p>${summary}</p>\n                            <a href=\"${link}\">More Details...</a>\n                        </div>\n                        `);\n                    if (lat.length && lon.length) {\n                        // when location exists create dom element for Marker\n                        const el = document.createElement('div');\n                        el.className = 'marker';\n                        // add markeres to map\n                        droneApp.markers = new mapboxgl.Marker(el)\n                        .setLngLat([lon, lat])\n                        .setPopup(popup)\n                        .addTo(droneApp.map);\n                        // push markers to empty array\n                        droneApp.markerArr.push([lon, lat])\n                    };\n                })\n            }\n        }\n        // fit map to marker bounds\n        // NOTE: SOLUTION 1: CREATE FEATURE GROUP (GEOJSON) FOR MARKERS, GET FEATURE GROUP BOUNDS\n        // create geojson object to store marker coordinates sotred in markerArry\n        const fitMap = () => {\n            const geojson = {\n                \"type\": \"FeatureCollection\",\n                \"features\": [{\n                    \"type\": \"Feature\",\n                    \"geometry\": {\n                        \"type\": \"Markers\",\n                        \"properties\": {},\n                        \"coordinates\": droneApp.markerArr\n                    }\n                }]\n            };\n            const coordinates = geojson.features[0].geometry.coordinates;\n\n            /* Pass the first coordinates in markerArry to `lngLatBounds` &\n            ** wrap each coordinate pair in `extend` to include them in the bounds\n            ** result. A variation of this technique could be applied to zooming\n            ** to the bounds of multiple Points or Polygon geomteries - it just\n            ** requires wrapping all the coordinates with the extend method. */\n            const bounds = coordinates.reduce(function(bounds, coord) {\n                return bounds.extend(coord);\n            }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));\n            droneApp.map.fitBounds(bounds, {padding:50});\n        }\n\n        displayMarkers();\n        fitMap();\n    }\n\n    droneApp.init = () => {\n        droneApp.filteringResult();\n        droneApp.initMap();\n        droneApp.displayStrikes();\n    }\n\n    droneApp.init();\n})\n"]}