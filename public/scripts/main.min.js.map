{"version":3,"sources":["main.js"],"names":["url","droneApp","mapboxgl","accessToken","getDrones","$","ajax","method","dataType","when","then","data","filterResults","strike","map","result","m_names","Array","date","split","splice","year","dateObj","Date","month","getMonth","displayDate","on","getCheckedInputValue","param","input","value","val","toArray","checkedYears","checkedCountries","defaultCountries","defaultYears","filteringResult","checkedValues","defaultValues","category","baseData","length","filteredRaw","criteria","filter","singleStrike","country","filteredResult","n","filteredStrikes","displayStrikes","strikeData","markerArr","markerData","forEach","lat","lon","town","summary","link","deaths","time","getPopupInfo","location","narrative","bij_summary_short","bij_link","number","join","featureObj","type","geometry","coordinates","properties","title","_id","description","iconSize","push","geojson","features","addSource","addLayer","id","source","layout","icon-image","icon-size","paint","marker","el","document","createElement","className","style","backgroundImgae","width","height","Marker","offset","setLngLat","addTo","e","queryRenderedFeatures","point","layers","feature","Popup","setHTML","fitMap","bounds","reduce","coord","extend","LngLatBounds","fitBounds","padding","flyTo","center","initMap","Map","container","zoom","maxZoom","init"],"mappings":"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","file":"main.min.js","sourcesContent":["// define callback url, app shell and mapbox key\nconst url = 'http://api.dronestre.am/data';\nconst droneApp = {};\nmapboxgl.accessToken = 'pk.eyJ1Ijoiam95OTAxN21hcGJveCIsImEiOiJjaW94M2RneXQwMDJ1d2ZtNXp4a29pbTV4In0.TebEkoRfRP8E0hw_Nd3PFA';\n\n// calling for drone results\n\ndroneApp.getDrones = $.ajax ({\n    url: url,\n    method: 'GET',\n    dataType: 'jsonp'\n});\n\n$.when(droneApp.getDrones).then(data => {\n    // show date as year form\n    droneApp.filterResults = () => {\n\n        data.strike.map(result => {\n            const m_names = new Array(\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\");\n            result.date = result.date.split('-').splice(0,2);\n            result.year = result.date[0];\n            let dateObj = new Date(result.date);\n            const month = m_names[dateObj.getMonth()];\n            result.displayDate = `${month}, ${result.year}`;\n        })\n        $(`input[type=checkbox]`).on('change', ()=> {\n\n            // collect chekced values into an array\n            let getCheckedInputValue = (param) => {\n                return $(`input[name=${param}]:checked`).map((input, value) => {\n                    return $(value).val()\n                }).toArray();\n            }\n            // define checked and default values for filter use\n            const checkedYears = getCheckedInputValue('year');\n            const checkedCountries = getCheckedInputValue('country');;\n            const defaultCountries = ['Yemen', 'Somalia', 'Pakistan'];\n            const defaultYears = ['2002', '2004', '2005', '2006', '2007', '2008', '2009', '2010', '2011', '2012', '2013', '2014', '2015', '2016'];\n\n            // filter resutls\n            const filteringResult = (checkedValues, defaultValues, category, baseData) => {\n                if(checkedValues.length !== 0) {\n                    // when the user makes a selection filter data against checked boxes\n                    var filteredRaw = checkedValues.map((criteria) => {\n                        return baseData.filter((singleStrike) => {\n                            if (category === 'year') {\n                                return singleStrike.year === criteria\n                            } else if (category === 'country') {\n                                return singleStrike.country === criteria\n                            }\n                        })\n                    })\n                } else {\n                    // when no selection is made, show all possible results\n                    var filteredRaw = defaultValues.map((criteria) => {\n                        return baseData.filter((singleStrike) => {\n                            if (category === 'year') {\n                                return singleStrike.year === criteria\n                            } else if (category === 'country') {\n                                return singleStrike.country === criteria;\n                            }\n                        })\n                    })\n                }\n                // turn filtered result, a multilevel array, into a flattened array\n                var filteredResult = $.map(filteredRaw, function(n) {\n                    return n\n                })\n                data.filteredStrikes = filteredResult;\n                // return data;\n            }\n            // first call for data to be filtered with an original dataset\n            filteringResult(checkedYears, defaultYears, 'year', data.strike);\n            // then call for data to be filtered wiht an filtered dataset\n            filteringResult(checkedCountries, defaultCountries, 'country',data.filteredStrikes);\n\n            // display strike markers on map\n            droneApp.displayStrikes(data.filteredStrikes);\n        }) // Checkbox on change\n    } // displayResults()\n\n    // display markers\n    droneApp.displayStrikes = (strikeData) => {\n        // create empty array to store markers\n        droneApp.markerArr = [];\n        droneApp.markerData = [];\n        // display markers\n        strikeData.forEach((singleStrike) => {\n            // define marker latitute and longtitute\n            const lat = singleStrike.lat\n            ,     lon = singleStrike.lon;\n            // define information contained in popup\n            let town, summary, link, deaths, time;\n            //NOTEðŸ‘‡: DO NOT DO THIS FIND A WAY TO WRAP THIS BETTER. USE TENERAY\n            const getPopupInfo = () => {\n                if (singleStrike.town.length && singleStrike.country.length) {\n                    town = singleStrike.town + singleStrike.country;\n                } else if (singleStrike.location.length){\n                    town = singleStrike.location + singleStrike.country\n                } else {\n                    town = 'Unknown'\n                }\n\n                if (singleStrike.narrative.length) {\n                    summary = singleStrike.narrative\n                } else if (singleStrike.bij_summary_short.length){\n                    summary = singleStrike.bij_summary_short\n                } else {\n                    summary = 'Awaiting detailed information on this strike...'\n                }\n\n                if (singleStrike.bij_link.length) {\n                    link = singleStrike.bij_summary_short.length\n                }\n\n                if (singleStrike.displayDate.length) {\n                    time = singleStrike.displayDate\n                }\n\n                let number = singleStrike.deaths;\n                if(number.length > 2) {\n                    deaths = number.split('-').join(' to ')\n                } else {\n                    deaths = number;\n                }\n            }\n            getPopupInfo();\n\n            // create geojson objsct for markers\n            const featureObj =\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": [lon, lat]\n                },\n                \"properties\": {\n                    \"title\": singleStrike._id,\n                    \"description\":\n                    `<div class=\"marker-content\">\n                    <p>${time}</p>\n                    <h3>${town}</h3>\n                    <h4>Deaths: ${deaths}</h4>\n                    <p>${summary}</p>\n                    <a href=\"${link}\">More Details...</a>\n                    </div>`,\n                    \"iconSize\": [40,40]\n                }\n            };\n            droneApp.markerData.push(featureObj);\n        })// forEach(singleStrike)\n\n        let geojson = {\n            \"type\": \"FeatureCollection\",\n            \"features\": droneApp.markerData\n        }\n\n        droneApp.map.addSource(\"strikes\", {\n            \"type\": \"geojson\",\n            \"data\": geojson\n        });\n\n        droneApp.map.addLayer({\n            \"id\": \"strikes\",\n             type: 'symbol',\n             source: 'strikes',\n             \"layout\": {\n                 \"icon-image\": \"harbor_icon\",\n                 \"icon-size\":1.5\n             },\n             \"paint\": {}\n       });\n\n        geojson.features.forEach(function(marker) {\n            const el = document.createElement('div');\n            el.className = 'marker';\n            el.style.backgroundImgae = 'url(../images/marker.svg)';\n            el.style.width = marker.properties.iconSize[0] + 'px';\n            el.style.height = marker.properties.iconSize[1] + 'px';\n\n            if (marker.geometry.coordinates[0].length && marker.geometry.coordinates[1].length) {\n                new mapboxgl.Marker(el, {\n                    offset: [-marker.properties.iconSize[0] / 2, -marker.properties.iconSize[1] / 2]\n                })\n                .setLngLat(marker.geometry.coordinates)\n                .addTo(droneApp.map);\n            }\n        });\n\n        droneApp.map.on('click', function(e) {\n            const features = droneApp.map.queryRenderedFeatures(e.point, { layers: ['strikes'] });\n\n            if (!features.length) {\n                return;\n            }\n\n            const feature = features[0];\n\n            const popup = new mapboxgl.Popup()\n            .setLngLat(feature.geometry.coordinates)\n            .setHTML(feature.properties.description)\n            .addTo(droneApp.map)\n        })\n\n        // fit map to marker bounds\n        // create geojson object to store marker coordinates sotred in markerArry\n        const fitMap = () => {\n            if(droneApp.markerArr.length > 1) {\n                const geojson = {\n                    \"type\": \"FeatureCollection\",\n                    \"features\": [{\n                        \"type\": \"Feature\",\n                        \"geometry\": {\n                            \"type\": \"Markers\",\n                            \"properties\": {},\n                            \"coordinates\": droneApp.markerArr\n                        }\n                    }]\n                };\n                const coordinates = geojson.features[0].geometry.coordinates;\n\n                /* Pass the first coordinates in markerArry to `lngLatBounds` &\n                ** wrap each coordinate pair in `extend` to include them in the bounds\n                ** result. A variation of this technique could be applied to zooming\n                ** to the bounds of multiple Points or Polygon geomteries - it just\n                ** requires wrapping all the coordinates with the extend method. */\n                const bounds = coordinates.reduce(function(bounds, coord) {\n                    return bounds.extend(coord);\n                }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));\n                droneApp.map.fitBounds(bounds, {padding:50});\n            } else if (droneApp.markerArr.length){\n                droneApp.map.flyTo({center:droneApp.markerArr[0]});\n            }// if(data.filteredStrikes)\n        } // fit map\n        fitMap();\n    } // displayStrikes()\n\n    //display map\n    droneApp.initMap = () => {\n        droneApp.map = new mapboxgl.Map({\n            container: 'map',\n            style: 'mapbox://styles/mapbox/satellite-v9',\n            center: [54.281023, 10.913129],\n            zoom: 3,\n            maxZoom: 13\n        })\n    }\n\n    // initiate drone app\n    droneApp.init = () => {\n        droneApp.initMap();\n        droneApp.filterResults();\n    }\n    droneApp.init();\n}) // promise\n"]}