{"version":3,"sources":["main.js"],"names":["url","droneApp","mapboxgl","accessToken","getDrones","$","ajax","method","dataType","when","then","data","markerData","mapArr","listArr","dataCleanUp","pakistanData","strike","filter","result","country","map","m_names","Array","date","split","splice","year","dateObj","Date","month","getMonth","displayDate","lat","lon","push","displayStrikes","strikeData","forEach","singleStrike","town","summary","link","deaths","time","min","getMarkerInfo","length","location","narrative","bij_summary_short","bij_link","number","join","min_deaths","featureObj","type","geometry","coordinates","properties","description","iconSize","minDeaths","geojson","features","on","addSource","addLayer","id","source","paint","circle-radius","circle-color","property","console","log","popup","Popup","closeButton","closeOnClick","e","queryRenderedFeatures","point","layers","getCanvas","style","cursor","remove","feature","setLngLat","setHTML","addTo","initMap","Map","container","center","zoom","maxZoom","init"],"mappings":"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","file":"main.min.js","sourcesContent":["// define callback url, app shell and mapbox key\nconst url = 'http://api.dronestre.am/data';\nconst droneApp = {};\nmapboxgl.accessToken = 'pk.eyJ1Ijoiam95OTAxN21hcGJveCIsImEiOiJjaW94M2RneXQwMDJ1d2ZtNXp4a29pbTV4In0.TebEkoRfRP8E0hw_Nd3PFA';\n\n// calling for drone results\n\ndroneApp.getDrones = $.ajax ({\n    url: url,\n    method: 'GET',\n    dataType: 'jsonp'\n});\n\n$.when(droneApp.getDrones).then(data => {\n    // show date as year form\n\n    // create empty array to store markers\n    droneApp.markerData = [];\n    droneApp.mapArr = [];\n    droneApp.listArr = [];\n\n    droneApp.dataCleanUp = () => {\n        const pakistanData = data.strike.filter(result => {\n            if (result.country) {\n                return result.country === 'Pakistan'\n            }\n        });\n\n        pakistanData.map((result) => {\n            const m_names = new Array(\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\");\n            result.date = result.date.split('-').splice(0,2);\n            result.year = result.date[0];\n            let dateObj = new Date(result.date);\n            const month = m_names[dateObj.getMonth()];\n            result.displayDate = `${month}, ${result.year}`;\n\n            if (!result.lat && !result.lon) {\n                droneApp.listArr.push(result);\n            } else {\n                droneApp.mapArr.push (result)\n            }\n        })\n    } // displayResults()\n\n    // display markers\n    droneApp.displayStrikes = (strikeData) => {\n        // display markers\n        strikeData.forEach((singleStrike) => {\n            // define information contained in popup\n            let lat, lon, town, summary, link, deaths, time, min;\n\n            //NOTEðŸ‘‡: DO NOT DO THIS FIND A WAY TO WRAP THIS BETTER. USE TENERAY\n            const getMarkerInfo = () => {\n                lat = singleStrike.lat;\n                lon = singleStrike.lon;\n\n                if (singleStrike.town.length && singleStrike.country.length) {\n                    town = singleStrike.town + ', ' + singleStrike.country;\n                } else if (singleStrike.location.length){\n                    town = singleStrike.location + ', ' + singleStrike.country\n                } else {\n                    town = 'Unknown'\n                }\n\n                if (singleStrike.narrative.length) {\n                    summary = singleStrike.narrative\n                } else if (singleStrike.bij_summary_short.length){\n                    summary = singleStrike.bij_summary_short\n                } else {\n                    summary = 'Awaiting detailed information on this strike...'\n                }\n\n                if (singleStrike.bij_link.length) {\n                    link = singleStrike.bij_summary_short.length\n                }\n\n                if (singleStrike.displayDate) {\n                    time = singleStrike.displayDate\n                }\n\n                let number = singleStrike.deaths;\n                if(number.length > 2) {\n                    deaths = number.split('-').join(' to ')\n                } else {\n                    deaths = number;\n                }\n\n                if(singleStrike.min_deaths) {\n                    min = singleStrike.min_deaths\n                }\n            }\n            getMarkerInfo();\n\n            // create geojson objsct for markers\n            const featureObj =\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": [lon, lat]\n                },\n                \"properties\": {\n                    \"description\":\n                    `<div class=\"marker-content\">\n                    <p>${time}</p>\n                    <h3>${town}</h3>\n                    <h4>Deaths: ${deaths}</h4>\n                    <p>${summary}</p>\n                    <a href=\"${link}\">More Details...</a>\n                    </div>`,\n                    \"iconSize\": [40,40],\n                    \"minDeaths\": min\n                }\n            };\n            droneApp.markerData.push(featureObj);\n        })// forEach(singleStrike)\n\n        const geojson = {\n            \"type\": \"FeatureCollection\",\n            \"features\": droneApp.markerData\n        }\n\n        droneApp.map.on('load', () => {\n            droneApp.map.addSource(\"strikes\", {\n                \"type\": \"geojson\",\n                \"data\": geojson\n            });\n\n            var layers = [\n                [0, 'green'],\n                [20, 'orange'],\n                [200, 'red']\n            ];\n\n            droneApp.map.addLayer({\n                \"id\": \"strikes\",\n                \"type\": \"circle\",\n                \"source\": \"strikes\",\n                \"paint\": {\n                    \"circle-radius\": 10,\n                    \"circle-color\": {\n                        property: \"minDeaths\"\n                    }\n                }\n            });\n\n            console.log(droneApp.map)\n        })\n        //create popups, but not adding them to map yet\n\n        let popup = new mapboxgl.Popup({\n            closeButton: false,\n            closeOnClick: false\n        });\n\n        droneApp.map.on('mousemove', function(e) {\n            const features = droneApp.map.queryRenderedFeatures(e.point, { layers: ['strikes'] });\n\n            // Change the cursor style as a UI indicator.\n            droneApp.map.getCanvas().style.cursor = (features.length) ? 'pointer' : '';\n\n            if (!features.length) {\n                popup.remove();\n                return;\n            }\n            const feature = features[0];\n\n            // Populate the popup and set its coordinates\n            // based on the feature found.\n            popup.setLngLat(feature.geometry.coordinates)\n            .setHTML(feature.properties.description)\n            .addTo(droneApp.map);\n        })\n\n        // fit map to marker bounds\n        // create geojson object to store marker coordinates sotred in markerArry\n        const fitMap = () => {\n            if(droneApp.markerArr.length > 1) {\n                const geojson = {\n                    \"type\": \"FeatureCollection\",\n                    \"features\": [{\n                        \"type\": \"Feature\",\n                        \"geometry\": {\n                            \"type\": \"Markers\",\n                            \"properties\": {},\n                            \"coordinates\": droneApp.markerArr\n                        }\n                    }]\n                };\n                const coordinates = geojson.features[0].geometry.coordinates;\n\n                /* Pass the first coordinates in markerArry to `lngLatBounds` &\n                ** wrap each coordinate pair in `extend` to include them in the bounds\n                ** result. A variation of this technique could be applied to zooming\n                ** to the bounds of multiple Points or Polygon geomteries - it just\n                ** requires wrapping all the coordinates with the extend method. */\n                const bounds = coordinates.reduce(function(bounds, coord) {\n                    return bounds.extend(coord);\n                }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));\n                droneApp.map.fitBounds(bounds, {padding:50});\n            } else if (droneApp.markerArr.length){\n                droneApp.map.flyTo({center:droneApp.markerArr[0]});\n            }// if(data.filteredStrikes)\n        } // fit map\n        // fitMap();\n    } // displayStrikes()\n\n    //display map\n    droneApp.initMap = () => {\n        droneApp.map = new mapboxgl.Map({\n            container: 'map',\n            style: 'mapbox://styles/mapbox/satellite-v9',\n            center: [54.281023, 10.913129],\n            zoom: 3,\n            maxZoom: 13\n        })\n    }\n\n    // initiate drone app\n    droneApp.init = () => {\n        droneApp.initMap();\n        droneApp.dataCleanUp();\n        droneApp.displayStrikes(droneApp.mapArr);\n    }\n    droneApp.init();\n}) // promise\n"]}